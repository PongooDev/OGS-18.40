#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CaretakerRuntime

#include "Basic.hpp"

#include "NavigationSystem_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Class CaretakerRuntime.FortAIAnimInstance_Caretaker
// 0x0060 (0x04B0 - 0x0450)
class UFortAIAnimInstance_Caretaker final : public UFortAIAnimInstance
{
public:
	bool                                          bIsMoving;                                         // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkPlayRate;                                      // 0x044C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetCurve;                                    // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhase_StopLeftPlant;                          // 0x0454(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhase_StopLeftPass;                           // 0x0455(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhase_StopRightPlant;                         // 0x0456(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFootPhase_StopRightPass;                          // 0x0457(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreathingCurve;                                    // 0x0458(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTreshold;                                    // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_AimOffsetCurve;                          // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_FootPhase;                               // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurveName_BreathingCurve;                          // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName_FX_Chest;                               // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName_ChestSocketLocation;                     // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName_ChestSocketVector;                       // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstFootPhaseMin;                                 // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFootPhaseMin;                                // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdFootPhaseMin;                                 // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FourthFootPhaseMin;                                // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootPhaseMax;                                      // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAnimWorldStriderComponent*         WorldStriderComponent;                             // 0x04A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDelayedMaterialParameters();

	float GetStartAnimPosition() const;
	float GetWalkPlayRateValue() const;
	float GetWalkSpeedWarpingValue() const;
	class UFortAnimWorldStriderComponent* GetWorldStriderComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAnimInstance_Caretaker">();
	}
	static class UFortAIAnimInstance_Caretaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAnimInstance_Caretaker>();
	}
};
static_assert(alignof(UFortAIAnimInstance_Caretaker) == 0x000010, "Wrong alignment on UFortAIAnimInstance_Caretaker");
static_assert(sizeof(UFortAIAnimInstance_Caretaker) == 0x0004B0, "Wrong size on UFortAIAnimInstance_Caretaker");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, bIsMoving) == 0x000448, "Member 'UFortAIAnimInstance_Caretaker::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, WalkPlayRate) == 0x00044C, "Member 'UFortAIAnimInstance_Caretaker::WalkPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, AimOffsetCurve) == 0x000450, "Member 'UFortAIAnimInstance_Caretaker::AimOffsetCurve' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, bFootPhase_StopLeftPlant) == 0x000454, "Member 'UFortAIAnimInstance_Caretaker::bFootPhase_StopLeftPlant' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, bFootPhase_StopLeftPass) == 0x000455, "Member 'UFortAIAnimInstance_Caretaker::bFootPhase_StopLeftPass' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, bFootPhase_StopRightPlant) == 0x000456, "Member 'UFortAIAnimInstance_Caretaker::bFootPhase_StopRightPlant' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, bFootPhase_StopRightPass) == 0x000457, "Member 'UFortAIAnimInstance_Caretaker::bFootPhase_StopRightPass' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, BreathingCurve) == 0x000458, "Member 'UFortAIAnimInstance_Caretaker::BreathingCurve' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, MovingTreshold) == 0x00045C, "Member 'UFortAIAnimInstance_Caretaker::MovingTreshold' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, CurveName_AimOffsetCurve) == 0x000460, "Member 'UFortAIAnimInstance_Caretaker::CurveName_AimOffsetCurve' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, CurveName_FootPhase) == 0x000468, "Member 'UFortAIAnimInstance_Caretaker::CurveName_FootPhase' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, CurveName_BreathingCurve) == 0x000470, "Member 'UFortAIAnimInstance_Caretaker::CurveName_BreathingCurve' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, SocketName_FX_Chest) == 0x000478, "Member 'UFortAIAnimInstance_Caretaker::SocketName_FX_Chest' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, ParamName_ChestSocketLocation) == 0x000480, "Member 'UFortAIAnimInstance_Caretaker::ParamName_ChestSocketLocation' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, ParamName_ChestSocketVector) == 0x000488, "Member 'UFortAIAnimInstance_Caretaker::ParamName_ChestSocketVector' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, FirstFootPhaseMin) == 0x000490, "Member 'UFortAIAnimInstance_Caretaker::FirstFootPhaseMin' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, SecondFootPhaseMin) == 0x000494, "Member 'UFortAIAnimInstance_Caretaker::SecondFootPhaseMin' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, ThirdFootPhaseMin) == 0x000498, "Member 'UFortAIAnimInstance_Caretaker::ThirdFootPhaseMin' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, FourthFootPhaseMin) == 0x00049C, "Member 'UFortAIAnimInstance_Caretaker::FourthFootPhaseMin' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, FootPhaseMax) == 0x0004A0, "Member 'UFortAIAnimInstance_Caretaker::FootPhaseMax' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance_Caretaker, WorldStriderComponent) == 0x0004A8, "Member 'UFortAIAnimInstance_Caretaker::WorldStriderComponent' has a wrong offset!");

// Class CaretakerRuntime.FortAITask_CaretakerMove
// 0x0000 (0x0180 - 0x0180)
class UFortAITask_CaretakerMove final : public UFortAbilityTask_MoveAI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAITask_CaretakerMove">();
	}
	static class UFortAITask_CaretakerMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAITask_CaretakerMove>();
	}
};
static_assert(alignof(UFortAITask_CaretakerMove) == 0x000008, "Wrong alignment on UFortAITask_CaretakerMove");
static_assert(sizeof(UFortAITask_CaretakerMove) == 0x000180, "Wrong size on UFortAITask_CaretakerMove");

// Class CaretakerRuntime.FortNavigationFilter_Caretaker
// 0x0018 (0x0060 - 0x0048)
class UFortNavigationFilter_Caretaker final : public UNavigationQueryFilter
{
public:
	float                                         EndPointAcceptableRadius;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     EndPointFilterClass;                               // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEndPointReachTestIncludesAgentRadius : 1;         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEndPointReachTestIncludesGoalRadius : 1;          // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_Caretaker">();
	}
	static class UFortNavigationFilter_Caretaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_Caretaker>();
	}
};
static_assert(alignof(UFortNavigationFilter_Caretaker) == 0x000008, "Wrong alignment on UFortNavigationFilter_Caretaker");
static_assert(sizeof(UFortNavigationFilter_Caretaker) == 0x000060, "Wrong size on UFortNavigationFilter_Caretaker");
static_assert(offsetof(UFortNavigationFilter_Caretaker, EndPointAcceptableRadius) == 0x000048, "Member 'UFortNavigationFilter_Caretaker::EndPointAcceptableRadius' has a wrong offset!");
static_assert(offsetof(UFortNavigationFilter_Caretaker, EndPointFilterClass) == 0x000050, "Member 'UFortNavigationFilter_Caretaker::EndPointFilterClass' has a wrong offset!");

// Class CaretakerRuntime.FortAthenaCaretakerAIController
// 0x0008 (0x0520 - 0x0518)
class AFortAthenaCaretakerAIController final : public AAthenaAIController
{
public:
	uint8                                         Pad_518[0x8];                                      // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugUpdate(float UpdateInterval);
	void OnMovementModeChanged(class ACharacter* CharacterOwner, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaCaretakerAIController">();
	}
	static class AFortAthenaCaretakerAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaCaretakerAIController>();
	}
};
static_assert(alignof(AFortAthenaCaretakerAIController) == 0x000008, "Wrong alignment on AFortAthenaCaretakerAIController");
static_assert(sizeof(AFortAthenaCaretakerAIController) == 0x000520, "Wrong size on AFortAthenaCaretakerAIController");

// Class CaretakerRuntime.FortBTTask_CaretakerMoveTo
// 0x0030 (0x00E0 - 0x00B0)
class UFortBTTask_CaretakerMoveTo final : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 FocalPointWhileMoving;                             // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableSlowdownAtGoal : 1;                         // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMoveDirectlyTowards : 1;                          // 0x00DC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopAtGoal : 1;                                   // 0x00DC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinishMoveOnOverlap : 1;                          // 0x00DC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_CaretakerMoveTo">();
	}
	static class UFortBTTask_CaretakerMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_CaretakerMoveTo>();
	}
};
static_assert(alignof(UFortBTTask_CaretakerMoveTo) == 0x000008, "Wrong alignment on UFortBTTask_CaretakerMoveTo");
static_assert(sizeof(UFortBTTask_CaretakerMoveTo) == 0x0000E0, "Wrong size on UFortBTTask_CaretakerMoveTo");
static_assert(offsetof(UFortBTTask_CaretakerMoveTo, FocalPointWhileMoving) == 0x0000B0, "Member 'UFortBTTask_CaretakerMoveTo::FocalPointWhileMoving' has a wrong offset!");
static_assert(offsetof(UFortBTTask_CaretakerMoveTo, PathObstacleAction) == 0x0000D8, "Member 'UFortBTTask_CaretakerMoveTo::PathObstacleAction' has a wrong offset!");

}

