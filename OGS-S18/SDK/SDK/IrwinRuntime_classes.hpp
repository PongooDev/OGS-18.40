#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IrwinRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "FortniteGame_classes.hpp"


namespace SDK
{

// Class IrwinRuntime.FortAIFaunaAnimInstance
// 0x0040 (0x0490 - 0x0450)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance : public UFortAIAnimInstance
{
public:
	float                                         AverageSpeed;                                      // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageSpeedTimeFrame;                             // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTargetLocation;                                 // 0x0454(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGround;                                 // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_462[0x2];                                      // 0x0462(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x0470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableHeadTrackingCurveName;                      // 0x0474(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0xC];                                      // 0x047C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateLookAtAlpha(bool bForceDisableLookAt, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance">();
	}
	static class UFortAIFaunaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance");
static_assert(sizeof(UFortAIFaunaAnimInstance) == 0x000490, "Wrong size on UFortAIFaunaAnimInstance");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeed) == 0x000448, "Member 'UFortAIFaunaAnimInstance::AverageSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeedTimeFrame) == 0x00044C, "Member 'UFortAIFaunaAnimInstance::AverageSpeedTimeFrame' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bHasValidAimTarget) == 0x000450, "Member 'UFortAIFaunaAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AimTargetLocation) == 0x000454, "Member 'UFortAIFaunaAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsSurfaceSwimming) == 0x000460, "Member 'UFortAIFaunaAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsMovingOnGround) == 0x000461, "Member 'UFortAIFaunaAnimInstance::bIsMovingOnGround' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtAlpha) == 0x000464, "Member 'UFortAIFaunaAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, MaxDistanceToPlayerForLookAt) == 0x000468, "Member 'UFortAIFaunaAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x00046C, "Member 'UFortAIFaunaAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bDisableLookAtDuringMontage) == 0x000470, "Member 'UFortAIFaunaAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, DisableHeadTrackingCurveName) == 0x000474, "Member 'UFortAIFaunaAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt
// 0x0060 (0x04F0 - 0x0490)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Burt : public UFortAIFaunaAnimInstance
{
public:
	float                                         MovingPlayRate;                                    // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltUpAdditive;                         // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0491(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_492[0x2];                                      // 0x0492(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLocomotionAdditiveCurveName;                // 0x0494(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InterruptibleCurveName;                            // 0x049C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToApex;                          // 0x04A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x04A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x04A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToIdle;                          // 0x04A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToJumpStart;                     // 0x04A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToApex;                     // 0x04A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionApexToFall;                          // 0x04AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToLand;                          // 0x04AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x04AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x04AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x04AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x04AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha_InterpSpeed;           // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier;   // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_ModOperand;               // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_TurnAngleThreshold;        // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle_LargeThreshold;                          // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt">();
	}
	static class UFortAIFaunaAnimInstance_Burt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Burt) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt) == 0x0004F0, "Wrong size on UFortAIFaunaAnimInstance_Burt");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate) == 0x000488, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha) == 0x00048C, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bEnableHeadTiltUpAdditive) == 0x000490, "Member 'UFortAIFaunaAnimInstance_Burt::bEnableHeadTiltUpAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bTurnAngleIsNegative) == 0x000491, "Member 'UFortAIFaunaAnimInstance_Burt::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, DisableLocomotionAdditiveCurveName) == 0x000494, "Member 'UFortAIFaunaAnimInstance_Burt::DisableLocomotionAdditiveCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveName) == 0x00049C, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToApex) == 0x0004A4, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToMoving) == 0x0004A5, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionMovingToIdle) == 0x0004A6, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToIdle) == 0x0004A7, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToJumpStart) == 0x0004A8, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToJumpStart' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionJumpStartToApex) == 0x0004A9, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionJumpStartToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionApexToFall) == 0x0004AA, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionApexToFall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToLand) == 0x0004AB, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToIdle) == 0x0004AC, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToIdle) == 0x0004AD, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToMoving) == 0x0004AE, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToMoving) == 0x0004AF, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SpeedThreshold) == 0x0004B0, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SlowSpeedDivisor) == 0x0004B4, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_FastSpeedDivisor) == 0x0004B8, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MinClamp) == 0x0004BC, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MaxClamp) == 0x0004C0, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_InterpSpeed) == 0x0004C4, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha_InterpSpeed) == 0x0004C8, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier) == 0x0004CC, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_ModOperand) == 0x0004D0, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_ModOperand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_LargeThreshold) == 0x0004D4, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_TurnAngleThreshold) == 0x0004D8, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_TurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_MovingThreshold) == 0x0004DC, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_IdleThreshold) == 0x0004E0, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, TurnAngle_LargeThreshold) == 0x0004E4, "Member 'UFortAIFaunaAnimInstance_Burt::TurnAngle_LargeThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt_Hitchhiker
// 0x0000 (0x04F0 - 0x04F0)
class UFortAIFaunaAnimInstance_Burt_Hitchhiker final : public UFortAIFaunaAnimInstance_Burt
{
public:
	bool                                          IsFloating;                                        // 0x04E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInTractorBeam;                                   // 0x04E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitchhiked;                                      // 0x04EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EB[0x5];                                      // 0x04EB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Burt_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x0004F0, "Wrong size on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsFloating) == 0x0004E8, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsInTractorBeam) == 0x0004E9, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsHitchhiked) == 0x0004EA, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma
// 0x0080 (0x0510 - 0x0490)
class UFortAIFaunaAnimInstance_Grandma : public UFortAIFaunaAnimInstance
{
public:
	class AFortAIPawn*                            AIPawn;                                            // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayFullBodyInPlace;                        // 0x0494(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_495[0x3];                                      // 0x0495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkAlpha;                                        // 0x0498(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunPlayRate;                                   // 0x049C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x04A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSniffAdditive;                              // 0x04A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAlertAdditive;                              // 0x04A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x04A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A7[0x1];                                      // 0x04A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedFullBodyInPlace;                           // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCurveValueFullBodyInPlace;                      // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SniffAdditiveFrequenceySeconds;                    // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertAdditiveFrequenceySeconds;                    // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnIDScale;                                       // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShouldPlayFullBodyInPlaceCurveName;                // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlinkAlphaCurveName;                               // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGroundORIsSurfaceSwimming;              // 0x04D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_DefaultJump_ToJumpApex;                 // 0x04D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x04D6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x04D7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnIdle;                        // 0x04D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x04D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x04DA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x04DB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x04DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Idle;                          // 0x04DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Moving;                        // 0x04DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_JumpApex;                     // 0x04DF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x04E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x04E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x04E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x04E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x04E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E5[0x3];                                      // 0x04E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingTurnIdleTransition;                     // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleStartTurnThreshold;                       // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0xC];                                      // 0x0504(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBlinkAlpha();
	float CalculateLocomotionPoseAlpha();
	float CalculateMeshScale();
	float CalculateWalkRunPlayRate();
	bool DetermineEnableAlertAdditive();
	bool DetermineEnableSniffAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineShouldPlayFullBodyInPlace();
	void UpdateBlinkAlpha();
	void UpdateEnableAlertAdditive();
	void UpdateEnableSniffAdditive();
	void UpdateIdleStartTurn();
	void UpdateLocomotionPoseAlpha();
	void UpdateMeshScale();
	void UpdateMovingRates();
	void UpdateShouldPlayFullBodyInPlace();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma">();
	}
	static class UFortAIFaunaAnimInstance_Grandma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma) == 0x000510, "Wrong size on UFortAIFaunaAnimInstance_Grandma");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AIPawn) == 0x000488, "Member 'UFortAIFaunaAnimInstance_Grandma::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MeshScale) == 0x000490, "Member 'UFortAIFaunaAnimInstance_Grandma::MeshScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bShouldPlayFullBodyInPlace) == 0x000494, "Member 'UFortAIFaunaAnimInstance_Grandma::bShouldPlayFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlpha) == 0x000498, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, WalkRunPlayRate) == 0x00049C, "Member 'UFortAIFaunaAnimInstance_Grandma::WalkRunPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlpha) == 0x0004A0, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableSniffAdditive) == 0x0004A4, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableSniffAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableAlertAdditive) == 0x0004A5, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableAlertAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleStartTurn) == 0x0004A6, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MaxSpeedFullBodyInPlace) == 0x0004A8, "Member 'UFortAIFaunaAnimInstance_Grandma::MaxSpeedFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MinCurveValueFullBodyInPlace) == 0x0004AC, "Member 'UFortAIFaunaAnimInstance_Grandma::MinCurveValueFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlphaInterpRate) == 0x0004B0, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SniffAdditiveFrequenceySeconds) == 0x0004B4, "Member 'UFortAIFaunaAnimInstance_Grandma::SniffAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AlertAdditiveFrequenceySeconds) == 0x0004B8, "Member 'UFortAIFaunaAnimInstance_Grandma::AlertAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, PawnIDScale) == 0x0004BC, "Member 'UFortAIFaunaAnimInstance_Grandma::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, ShouldPlayFullBodyInPlaceCurveName) == 0x0004C0, "Member 'UFortAIFaunaAnimInstance_Grandma::ShouldPlayFullBodyInPlaceCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlphaCurveName) == 0x0004C8, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleStartTurnInterruptibleThreshold) == 0x0004D0, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsMovingOnGroundORIsSurfaceSwimming) == 0x0004D4, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsMovingOnGroundORIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_DefaultJump_ToJumpApex) == 0x0004D5, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_DefaultJump_ToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Idle) == 0x0004D6, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Moving) == 0x0004D7, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnIdle) == 0x0004D8, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnMoving_Moving) == 0x0004D9, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnMoving) == 0x0004DA, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Idle_Moving) == 0x0004DB, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_Idle) == 0x0004DC, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Idle) == 0x0004DD, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Moving) == 0x0004DE, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpStart_JumpApex) == 0x0004DF, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpStart_JumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimIdle_SwimLoco) == 0x0004E0, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimLoco_SwimIdle) == 0x0004E1, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimIdle) == 0x0004E2, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimLoco) == 0x0004E3, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bAnimRule_NegativeTurnAngle) == 0x0004E4, "Member 'UFortAIFaunaAnimInstance_Grandma::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, InterruptibleMaxCheck) == 0x0004E8, "Member 'UFortAIFaunaAnimInstance_Grandma::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedStopTransition) == 0x0004EC, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleMoveTransition) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedMovingTurnIdleTransition) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedMovingTurnIdleTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMin) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, StateTimeFromEndThreshold) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Grandma::StateTimeFromEndThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleStartTurnThreshold) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleStartTurnThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma_Hitchhiker
// 0x0010 (0x0520 - 0x0510)
class UFortAIFaunaAnimInstance_Grandma_Hitchhiker final : public UFortAIFaunaAnimInstance_Grandma
{
public:
	bool                                          bIsHitchhiked;                                     // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrandmaSprinting;                               // 0x0511(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x0512(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x0513(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCheckSpeed;                                  // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x8];                                      // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Grandma_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000520, "Wrong size on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsHitchhiked) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsHitchhiked' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsGrandmaSprinting) == 0x000511, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsGrandmaSprinting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsFloating) == 0x000512, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsInTractorBeam) == 0x000513, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, SprintCheckSpeed) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::SprintCheckSpeed' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug
// 0x0060 (0x04F0 - 0x0490)
class UFortAIFaunaAnimInstance_Nug : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsBeingHeld;                                      // 0x0488(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBodyMaskAlpha;                                // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExitJump;                                   // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingPlayRate;                                    // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLean;                                       // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanDirection;                                     // 0x049C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InterruptibleCurveName;                            // 0x04A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToIdleTurn;                      // 0x04AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToLocomotionTurn;                // 0x04AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x04AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToJumpApex;                      // 0x04AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x04B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToJumpApex;                 // 0x04B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpApexToJumpLoop;                  // 0x04B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x04B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x04B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x04B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x04B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B7[0x1];                                      // 0x04B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShouldExitJump_SpeedThreshold;                     // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanDirection_SpeedThreshold;                      // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldLean_SpeedThreshold;                         // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTurnTransition_SpeedThreshold;                 // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTurnTransition_SpeedThreshold;           // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug">();
	}
	static class UFortAIFaunaAnimInstance_Nug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug) == 0x0004F0, "Wrong size on UFortAIFaunaAnimInstance_Nug");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingHeld) == 0x000488, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingHeld' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LowerBodyMaskAlpha) == 0x00048C, "Member 'UFortAIFaunaAnimInstance_Nug::LowerBodyMaskAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldExitJump) == 0x000490, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldExitJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate) == 0x000494, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldLean) == 0x000498, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldLean' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection) == 0x00049C, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bTurnAngleIsNegative) == 0x0004A0, "Member 'UFortAIFaunaAnimInstance_Nug::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveName) == 0x0004A4, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToIdleTurn) == 0x0004AC, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToLocomotionTurn) == 0x0004AD, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToLocomotionTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToMoving) == 0x0004AE, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToJumpApex) == 0x0004AF, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionMovingToIdle) == 0x0004B0, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpStartToJumpApex) == 0x0004B1, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpStartToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpApexToJumpLoop) == 0x0004B2, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpApexToJumpLoop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToIdle) == 0x0004B3, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToMoving) == 0x0004B4, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToMoving) == 0x0004B5, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToIdle) == 0x0004B6, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldExitJump_SpeedThreshold) == 0x0004B8, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldExitJump_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SpeedThreshold) == 0x0004BC, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SlowSpeedDivisor) == 0x0004C0, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_FastSpeedDivisor) == 0x0004C4, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_InterpSpeed) == 0x0004C8, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MinClamp) == 0x0004CC, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MaxClamp) == 0x0004D0, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection_SpeedThreshold) == 0x0004D4, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldLean_SpeedThreshold) == 0x0004D8, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldLean_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveValue_LargeThreshold) == 0x0004DC, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_MovingThreshold) == 0x0004E0, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_IdleThreshold) == 0x0004E4, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleTurnTransition_SpeedThreshold) == 0x0004E8, "Member 'UFortAIFaunaAnimInstance_Nug::IdleTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LocomotionTurnTransition_SpeedThreshold) == 0x0004EC, "Member 'UFortAIFaunaAnimInstance_Nug::LocomotionTurnTransition_SpeedThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug_Hitchhiker
// 0x0010 (0x0500 - 0x04F0)
class UFortAIFaunaAnimInstance_Nug_Hitchhiker final : public UFortAIFaunaAnimInstance_Nug
{
public:
	bool                                          bIsSwimming;                                       // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingThrown;                                    // 0x04F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x04F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x04F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitchhiked;                                     // 0x04F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIsBeingHeldToChickenChuck;           // 0x04F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F6[0xA];                                      // 0x04F6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Nug_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000500, "Wrong size on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsSwimming) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsBeingThrown) == 0x0004F1, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsBeingThrown' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsInTractorBeam) == 0x0004F2, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsFloating) == 0x0004F3, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsHitchhiked) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsHitchhiked' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bCanTransitionIsBeingHeldToChickenChuck) == 0x0004F5, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bCanTransitionIsBeingHeldToChickenChuck' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Robert
// 0x0050 (0x04E0 - 0x0490)
class UFortAIFaunaAnimInstance_Robert final : public UFortAIFaunaAnimInstance
{
public:
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            AIPawn;                                            // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltDownAdditive;                       // 0x0499(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullBodyInPlace;                                // 0x049A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49B[0x1];                                      // 0x049B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x049C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnIDScale;                                       // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadTiltDownAdditiveFrequenceySeconds;             // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFullBodyTransition;                           // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x04B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_TurnIdle;                          // 0x04B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x04B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_TurnIdle;                    // 0x04B7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x04B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x04B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x04BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x04BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Swimming_Fall;                          // 0x04BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Land_Idle;                              // 0x04BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_Apex;                         // 0x04BE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x04BF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x04C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x04C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x04C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x04C3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleMaxCheck;                             // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateLocomotionPoseAdditiveAlpha();
	bool DetermineEnableHeadTiltDownAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineIsFullBodyInPlace();
	void UpdateEnableHeadTiltDownAdditive();
	void UpdateIdleStartTurn();
	void UpdateIsFullBodyInPlace();
	void UpdateLocomotionPoseAdditiveAlpha();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Robert">();
	}
	static class UFortAIFaunaAnimInstance_Robert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Robert>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Robert) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Robert");
static_assert(sizeof(UFortAIFaunaAnimInstance_Robert) == 0x0004E0, "Wrong size on UFortAIFaunaAnimInstance_Robert");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AIPawn) == 0x000490, "Member 'UFortAIFaunaAnimInstance_Robert::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleStartTurn) == 0x000498, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bEnableHeadTiltDownAdditive) == 0x000499, "Member 'UFortAIFaunaAnimInstance_Robert::bEnableHeadTiltDownAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFullBodyInPlace) == 0x00049A, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlpha) == 0x00049C, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PawnIDScale) == 0x0004A0, "Member 'UFortAIFaunaAnimInstance_Robert::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HeadTiltDownAdditiveFrequenceySeconds) == 0x0004A4, "Member 'UFortAIFaunaAnimInstance_Robert::HeadTiltDownAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, ForceFullBodyTransition) == 0x0004A8, "Member 'UFortAIFaunaAnimInstance_Robert::ForceFullBodyTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlphaInterpRate) == 0x0004AC, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleStartTurnInterruptibleThreshold) == 0x0004B0, "Member 'UFortAIFaunaAnimInstance_Robert::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Idle) == 0x0004B4, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_TurnIdle) == 0x0004B5, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Moving) == 0x0004B6, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_TurnIdle) == 0x0004B7, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_Moving) == 0x0004B8, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_Idle) == 0x0004B9, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_Moving) == 0x0004BA, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_TurnMoving) == 0x0004BB, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Swimming_Fall) == 0x0004BC, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Swimming_Fall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Land_Idle) == 0x0004BD, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Land_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_JumpStart_Apex) == 0x0004BE, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_JumpStart_Apex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimIdle_SwimLoco) == 0x0004BF, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimLoco_SwimIdle) == 0x0004C0, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimIdle) == 0x0004C1, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimLoco) == 0x0004C2, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bAnimRule_NegativeTurnAngle) == 0x0004C3, "Member 'UFortAIFaunaAnimInstance_Robert::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, InterruptibleMaxCheck) == 0x0004C4, "Member 'UFortAIFaunaAnimInstance_Robert::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedStopTransition) == 0x0004C8, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedIdleMoveTransition) == 0x0004CC, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedToMoveMin) == 0x0004D0, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, StateTimeFromEndThreshold) == 0x0004D4, "Member 'UFortAIFaunaAnimInstance_Robert::StateTimeFromEndThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Smackie
// 0x0000 (0x0490 - 0x0490)
class UFortAIFaunaAnimInstance_Smackie final : public UFortAIFaunaAnimInstance
{
public:
	float                                         SpeedThreshold;                                    // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToHop;                           // 0x048C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionHopToIdle;                           // 0x048D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48E[0x2];                                      // 0x048E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Smackie">();
	}
	static class UFortAIFaunaAnimInstance_Smackie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Smackie>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Smackie) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Smackie");
static_assert(sizeof(UFortAIFaunaAnimInstance_Smackie) == 0x000490, "Wrong size on UFortAIFaunaAnimInstance_Smackie");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, SpeedThreshold) == 0x000488, "Member 'UFortAIFaunaAnimInstance_Smackie::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionIdleToHop) == 0x00048C, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionIdleToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionHopToIdle) == 0x00048D, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionHopToIdle' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaLayerAnimInstance
// 0x0000 (0x0360 - 0x0360)
class UFortAIFaunaLayerAnimInstance final : public UFortBaseLayerAnimInstance
{
public:
	class UAnimInstance*                          MainAnimBP;                                        // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaLayerAnimInstance">();
	}
	static class UFortAIFaunaLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaLayerAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaLayerAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaLayerAnimInstance");
static_assert(sizeof(UFortAIFaunaLayerAnimInstance) == 0x000360, "Wrong size on UFortAIFaunaLayerAnimInstance");
static_assert(offsetof(UFortAIFaunaLayerAnimInstance, MainAnimBP) == 0x000358, "Member 'UFortAIFaunaLayerAnimInstance::MainAnimBP' has a wrong offset!");

}

