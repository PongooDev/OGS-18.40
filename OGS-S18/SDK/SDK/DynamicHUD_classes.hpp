#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicHUD

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DynamicHUD_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class DynamicHUD.DynamicHUDConstraintBase
// 0x0050 (0x0078 - 0x0028)
class UDynamicHUDConstraintBase : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicHUDConstraintOverrideBase*      ConstraintOverride;                                // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseOffset : 1;                                    // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseOverride : 1;                                  // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintBase">();
	}
	static class UDynamicHUDConstraintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintBase>();
	}
};
static_assert(alignof(UDynamicHUDConstraintBase) == 0x000008, "Wrong alignment on UDynamicHUDConstraintBase");
static_assert(sizeof(UDynamicHUDConstraintBase) == 0x000078, "Wrong size on UDynamicHUDConstraintBase");
static_assert(offsetof(UDynamicHUDConstraintBase, Offset) == 0x000060, "Member 'UDynamicHUDConstraintBase::Offset' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintBase, ConstraintOverride) == 0x000068, "Member 'UDynamicHUDConstraintBase::ConstraintOverride' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintWidget
// 0x0058 (0x00D0 - 0x0078)
class UDynamicHUDConstraintWidget final : public UDynamicHUDConstraintBase
{
public:
	EDynamicHUDAnchor                             Anchor;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   TargetWidget;                                      // 0x0080(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetUniqueID;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDynamicHUDAnchor                             TargetAnchor;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDynamicHUDConstraintWidgetFallback> Fallbacks;                                         // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUseFallbacks : 1;                                 // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintWidget">();
	}
	static class UDynamicHUDConstraintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintWidget>();
	}
};
static_assert(alignof(UDynamicHUDConstraintWidget) == 0x000008, "Wrong alignment on UDynamicHUDConstraintWidget");
static_assert(sizeof(UDynamicHUDConstraintWidget) == 0x0000D0, "Wrong size on UDynamicHUDConstraintWidget");
static_assert(offsetof(UDynamicHUDConstraintWidget, Anchor) == 0x000078, "Member 'UDynamicHUDConstraintWidget::Anchor' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, TargetWidget) == 0x000080, "Member 'UDynamicHUDConstraintWidget::TargetWidget' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, TargetUniqueID) == 0x0000A8, "Member 'UDynamicHUDConstraintWidget::TargetUniqueID' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, TargetAnchor) == 0x0000B0, "Member 'UDynamicHUDConstraintWidget::TargetAnchor' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, Fallbacks) == 0x0000B8, "Member 'UDynamicHUDConstraintWidget::Fallbacks' has a wrong offset!");

// Class DynamicHUD.DynamicHUDDirectorBase
// 0x0010 (0x0230 - 0x0220)
class ADynamicHUDDirectorBase : public AActor
{
public:
	TArray<class UDynamicHUDScene*>               DefaultScenes;                                     // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDDirectorBase">();
	}
	static class ADynamicHUDDirectorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicHUDDirectorBase>();
	}
};
static_assert(alignof(ADynamicHUDDirectorBase) == 0x000008, "Wrong alignment on ADynamicHUDDirectorBase");
static_assert(sizeof(ADynamicHUDDirectorBase) == 0x000230, "Wrong size on ADynamicHUDDirectorBase");
static_assert(offsetof(ADynamicHUDDirectorBase, DefaultScenes) == 0x000220, "Member 'ADynamicHUDDirectorBase::DefaultScenes' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintPosition
// 0x0010 (0x0088 - 0x0078)
class UDynamicHUDConstraintPosition final : public UDynamicHUDConstraintBase
{
public:
	struct FVector2D                              Position;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDynamicHUDAnchor                             Anchor;                                            // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintPosition">();
	}
	static class UDynamicHUDConstraintPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintPosition>();
	}
};
static_assert(alignof(UDynamicHUDConstraintPosition) == 0x000008, "Wrong alignment on UDynamicHUDConstraintPosition");
static_assert(sizeof(UDynamicHUDConstraintPosition) == 0x000088, "Wrong size on UDynamicHUDConstraintPosition");
static_assert(offsetof(UDynamicHUDConstraintPosition, Position) == 0x000078, "Member 'UDynamicHUDConstraintPosition::Position' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintPosition, Anchor) == 0x000080, "Member 'UDynamicHUDConstraintPosition::Anchor' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintOverrideBase
// 0x0000 (0x0028 - 0x0028)
class UDynamicHUDConstraintOverrideBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintOverrideBase">();
	}
	static class UDynamicHUDConstraintOverrideBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintOverrideBase>();
	}
};
static_assert(alignof(UDynamicHUDConstraintOverrideBase) == 0x000008, "Wrong alignment on UDynamicHUDConstraintOverrideBase");
static_assert(sizeof(UDynamicHUDConstraintOverrideBase) == 0x000028, "Wrong size on UDynamicHUDConstraintOverrideBase");

// Class DynamicHUD.DynamicHUDConstraintAlignment
// 0x0008 (0x0080 - 0x0078)
class UDynamicHUDConstraintAlignment final : public UDynamicHUDConstraintBase
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EDynamicHUDAnchor                             Anchor;                                            // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintAlignment">();
	}
	static class UDynamicHUDConstraintAlignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintAlignment>();
	}
};
static_assert(alignof(UDynamicHUDConstraintAlignment) == 0x000008, "Wrong alignment on UDynamicHUDConstraintAlignment");
static_assert(sizeof(UDynamicHUDConstraintAlignment) == 0x000080, "Wrong size on UDynamicHUDConstraintAlignment");
static_assert(offsetof(UDynamicHUDConstraintAlignment, HorizontalAlignment) == 0x000078, "Member 'UDynamicHUDConstraintAlignment::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, VerticalAlignment) == 0x000079, "Member 'UDynamicHUDConstraintAlignment::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, Anchor) == 0x00007C, "Member 'UDynamicHUDConstraintAlignment::Anchor' has a wrong offset!");

// Class DynamicHUD.DynamicHUDManager
// 0x0118 (0x0148 - 0x0030)
class UDynamicHUDManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDynamicHUDScene*, struct FContextData> ActiveScenes;                                      // 0x0080(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FDirectorData>     ActiveDirectors;                                   // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddScene(const class UDynamicHUDScene* Scene, const class UObject* OptionalContext);
	void AddScenes(const TArray<class UDynamicHUDScene*>& Scenes, const class UObject* OptionalContext);
	void RemoveScene(const class UDynamicHUDScene* Scene, const class UObject* OptionalContext);
	void RemoveScenes(const TArray<class UDynamicHUDScene*>& Scenes, const class UObject* OptionalContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDManager">();
	}
	static class UDynamicHUDManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDManager>();
	}
};
static_assert(alignof(UDynamicHUDManager) == 0x000008, "Wrong alignment on UDynamicHUDManager");
static_assert(sizeof(UDynamicHUDManager) == 0x000148, "Wrong size on UDynamicHUDManager");
static_assert(offsetof(UDynamicHUDManager, ActiveScenes) == 0x000080, "Member 'UDynamicHUDManager::ActiveScenes' has a wrong offset!");
static_assert(offsetof(UDynamicHUDManager, ActiveDirectors) == 0x0000F8, "Member 'UDynamicHUDManager::ActiveDirectors' has a wrong offset!");

// Class DynamicHUD.DynamicHUDScene
// 0x0020 (0x0050 - 0x0030)
class UDynamicHUDScene final : public UDataAsset
{
public:
	TArray<struct FDynamicHUDAllowed>             Allowed;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDynamicHUDUnallowed>           Unallowed;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDScene">();
	}
	static class UDynamicHUDScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDScene>();
	}
};
static_assert(alignof(UDynamicHUDScene) == 0x000008, "Wrong alignment on UDynamicHUDScene");
static_assert(sizeof(UDynamicHUDScene) == 0x000050, "Wrong size on UDynamicHUDScene");
static_assert(offsetof(UDynamicHUDScene, Allowed) == 0x000030, "Member 'UDynamicHUDScene::Allowed' has a wrong offset!");
static_assert(offsetof(UDynamicHUDScene, Unallowed) == 0x000040, "Member 'UDynamicHUDScene::Unallowed' has a wrong offset!");

// Class DynamicHUD.DynamicHUDVisualizerWidget
// 0x0028 (0x0288 - 0x0260)
class UDynamicHUDVisualizerWidget final : public UUserWidget
{
public:
	TArray<class UDynamicHUDScene*>               Scenes;                                            // 0x0260(0x0010)(Edit, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bRefresh;                                          // 0x0270(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x17];                                     // 0x0271(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDVisualizerWidget">();
	}
	static class UDynamicHUDVisualizerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDVisualizerWidget>();
	}
};
static_assert(alignof(UDynamicHUDVisualizerWidget) == 0x000008, "Wrong alignment on UDynamicHUDVisualizerWidget");
static_assert(sizeof(UDynamicHUDVisualizerWidget) == 0x000288, "Wrong size on UDynamicHUDVisualizerWidget");
static_assert(offsetof(UDynamicHUDVisualizerWidget, Scenes) == 0x000260, "Member 'UDynamicHUDVisualizerWidget::Scenes' has a wrong offset!");
static_assert(offsetof(UDynamicHUDVisualizerWidget, bRefresh) == 0x000270, "Member 'UDynamicHUDVisualizerWidget::bRefresh' has a wrong offset!");

}

